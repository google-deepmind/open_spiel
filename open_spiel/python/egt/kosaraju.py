import scipy.sparse as sps


class Graph(object):
    """Implementation of Kosaraju's algorithm for computing communicating classes of a
    directed graph, expressed as an adjacency matrix.  Taken from 
    http://www.kylesauri.com/home/kosarajus-algorithm-in-python-3.

    Some methods are implemented in a non-recursive way to avoid recursion limit.
    """

    def __init__(self, mat, zeroTest):
        """Takes an adjacency matrix and prepares for computing its communicating
        and closed classes.
        """
        s = mat.shape
        self.dim = s[0]
        assert(self.dim==s[1] and len(s)==2)
        self.zeroTest = zeroTest
        self.mat = mat
        self.is_sparse = sps.issparse(mat)
        self.communicatingClasses = None
        self.closedClasses = None


    def Visit(self, vertex):
        """Performs a depth-first search of the graph starting 
        from the given node/vertex to compute a list of 
        sortedVertices consistent with the pre-order generated by
        adjacency, keeping track of progress via the list of 
        visited vertices.
        """

        if vertex in self.visited:
            return
        visited_set = set(self.visited)

        stack = [(vertex, False)]
        while stack:
            v, processed = stack.pop()

            if processed:
                self.sortedVertices.insert(0, v)
                continue

            if v in visited_set:
                continue

            self.visited.append(v)
            visited_set.add(v)
            stack.append((v, True))

            if self.is_sparse:
                col = self.mat.getcol(v)
                nbrs = col.nonzero()[0]
                for neighbor in sorted(nbrs, reverse=True):
                    if neighbor in visited_set:
                        continue
                    val = self.mat[neighbor, v]
                    if not self.zeroTest(val):
                        stack.append((neighbor, False))
            else:
                for neighbor in range(self.dim - 1, -1, -1):
                    if not self.zeroTest(self.mat[neighbor, v]) and neighbor not in visited_set:
                        stack.append((neighbor, False))


    def Assign(self, vertex, root):
        """Associate a vertex with its communicating class representative, root,
        via the components dictionary. 
        """
        stack = [vertex]
        while stack:
            v = stack.pop()
            if v in self.components:
                continue
            self.components[v] = root
            if self.is_sparse:
                row = self.mat.getrow(v)
                nbrs = row.nonzero()[1]
                for neighbor in nbrs:
                    if neighbor in self.components:
                        continue
                    val = self.mat[v, neighbor]
                    if not self.zeroTest(val):
                        stack.append(neighbor)
            else:
                for neighbor in range(self.dim):
                    if not self.zeroTest(self.mat[v, neighbor]) and neighbor not in self.components:
                        stack.append(neighbor)
 

    def CommunicatingClasses(self):
        """Apply Kosaraju's algorithm to compute the set of communicating classes,
        espressed as a dictionary of representatives from each class with the
        associate values given by the classes, as arrays. 
        """

        if (self.communicatingClasses):
            return self.communicatingClasses

        self.visited = []
        self.sortedVertices = []
        self.components = {}

        for vertex in range(self.dim):
            self.Visit(vertex)
        
        for vertex in self.sortedVertices:
            self.Assign(vertex, vertex)

        self.communicatingClasses = {}
        for vertex in range(self.dim):
            root = self.components[vertex]
            if root in self.communicatingClasses:
                self.communicatingClasses[root].append(vertex)
            else:
                self.communicatingClasses[root] = [vertex]

        return self.communicatingClasses


    def ClosedClasses(self):

        if (self.closedClasses):
            return self.closedClasses

        if(not self.communicatingClasses):
            self.communicatingClasses = self.CommunicatingClasses()
        
        self.closedClasses = {}
        for cc in self.communicatingClasses.keys():

            # Assume that it is closed for now
            self.closedClasses[cc] = self.communicatingClasses[cc]
            for source in self.communicatingClasses[cc]:
                if self.is_sparse:
                    col = self.mat.getcol(source)
                    nbrs = col.nonzero()[0]
                    outside_found = False
                    for target in nbrs:
                        if target in self.communicatingClasses[cc]:
                            continue
                        val = self.mat[target, source]
                        if not self.zeroTest(val):
                            outside_found = True
                            break
                    if outside_found:
                        self.closedClasses.pop(cc)
                        break
                else:
                    for target in range(self.dim):
                        if target not in self.communicatingClasses[cc] and \
                                not self.zeroTest(self.mat[target, source]):
                            self.closedClasses.pop(cc)
                            break

                    if cc not in self.closedClasses:
                        break

        return self.closedClasses

import numpy as np
if __name__ == '__main__':
    m = np.array(
        [2/3, 1/4, 0, 2/3, 0, 
        1/3, 3/4, 0, 0, 0, 
        0, 0, 3/5, 1/6, 4/7, 
        0, 0, 2/5, 1/2, 0, 
        0, 0, 0, 0, 3/7]).reshape(5, 5)


    def zeroTest(x):
        return x == 0

    g = Graph(m, zeroTest)
    print("np matrix:")
    print(g.CommunicatingClasses())    
    print(g.ClosedClasses())


    m_sparse = sps.csr_matrix(
        np.array(
        [2/3, 1/4, 0, 2/3, 0, 
        1/3, 3/4, 0, 0, 0, 
        0, 0, 3/5, 1/6, 4/7, 
        0, 0, 2/5, 1/2, 0, 
        0, 0, 0, 0, 3/7]).reshape(5, 5)
    )


    g = Graph(m_sparse, zeroTest)
    print("sparse csr matrix:")
    print(g.CommunicatingClasses())    
    print(g.ClosedClasses())